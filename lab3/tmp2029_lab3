#!/usr/bin/env python3
# Tony Pham
# 1001842029
# 2025-07-10
# macOS 10.15.7

import os      # to find and work with files
import sys     # so we can report errors and exit cleanly


# 
# A Simple Stack to Hold Our Numbers
# 
class Stack:
    #A little bucket where we push and pop values in LIFO order.#
    
    def __init__(self):
        # Start with an empty list inside
        self._items = []

    def push(self, item):
        #Drop a new item on top of the stack.
        self._items.append(item)

    def pop(self):

        # If we try to pop from an empty stack, raise an error
        # to let the user know they messed up.
        if not self._items:
            raise IndexError("Oops—stack is empty, nothing to pop!")
        return self._items.pop()

    def is_empty(self):
        #Quick check: is there anything left in our stack?#
        return len(self._items) == 0

    def __len__(self):
        #Allow len(stack) to tell us how many things are in there.#
        return len(self._items)



# Core RPN Calculator Logic

def evaluate_rpn(tokens):
    
    """
    Crunch a Reverse Polish Notation expression and return the answer.

    Imagine each token as either:
      - a single-digit number (we push it onto our stack), or
      - an operator (+, -, *, /) that combines the top two numbers.

    By the end, exactly one number should remain—that’s our result.
    """
    
    stack = Stack()

    for tok in tokens:
        if tok.isdigit():
            # It's a number! Convert to int and stash it.
            stack.push(int(tok))

        elif tok in ('+', '-', '*', '/'):
            # It's an operator. We need two numbers to work with.
            if len(stack) < 2:
                raise ValueError(f"Not enough numbers for '{tok}' operation.")
            b = stack.pop()  # second operand
            a = stack.pop()  # first operand

            # Do the math and push the answer back on the stack.
            if tok == '+':
                stack.push(a + b)
            elif tok == '-':
                stack.push(a - b)
            elif tok == '*':
                stack.push(a * b)
            else:  # tok == '/'
                # We’ll do true division here; if you want integer division,
                # swap this for a // b instead.
                stack.push(a / b)

        else:
            # Anything else is unexpected—complain loudly.
            raise ValueError(f"Yikes—don’t know what '{tok}' means.")

    # After processing every token, we should have exactly one final answer.
    if len(stack) != 1:
        raise ValueError("Hmm, something went wrong—more or fewer than one value left.")

    return stack.pop()


# Putting It All Together: Reading the File & Printing Results
def main():
    # Figure out where this script lives
    script_dir = os.path.dirname(os.path.realpath(__file__))
    # Build the path to our input file sitting alongside it
    input_path = os.path.join(script_dir, 'input_RPN.txt')

    try:
        # Open that file and tackle it one line at a time
        with open(input_path, 'r') as f:
            for raw_line in f:
                line = raw_line.strip()

                # Skip anything blank or just whitespace
                if not line or line.startswith('#'):
                    continue

                tokens = line.split()
                try:
                    answer = evaluate_rpn(tokens)
                    # If division gave us something like 6.0, show it as 6.
                    if isinstance(answer, float) and answer.is_integer():
                        answer = int(answer)
                    print(answer)

                except Exception as err:
                    # If something unexpected happens, show a helpful message
                    print(f"Error processing '{line}': {err}", file=sys.stderr)

    except FileNotFoundError:
        # If we can’t even find the file, let the user know and bail out
        print(f"Couldn’t find input_RPN.txt in {script_dir}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
